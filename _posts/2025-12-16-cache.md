---
title: "Is SIEVE Really Better Than LRU for DNS Caches?"
tags:
  - Technitium DNS Server
  - DNS
  - Open Source
  - Community Contribution
---

A friend of mine once said, *“It may be subjective, but Technitium DNS feels faster than BIND.”*
That sentence stuck with me.

As engineers, we hear this often. Something *feels* faster. Something *behaves* better under load. But intuition is not evidence, and anecdotes are not benchmarks. When I searched for concrete data, I did not find a direct comparison. What I did find was an excellent article from ISC: **[SIEVE – A Better Algorithm Than LRU?](https://www.isc.org/blogs/2025-sieve/)**. That article explains why BIND 9 adopted **SIEVE** and shows convincing production results. It also triggered a more focused question for me:

> Is the newer BIND cache behavior fundamentally better than Technitium DNS’s cache, or are we mostly comparing *different engineering trade-offs*?

Instead of a very complext DNS server benchmark harness, I wanted to compare cache eviction strategies as a more feasible and less time-consuming effort. This article documents a small, controlled experiment to explore that question.

## Scope and Methodology

This is **not** a benchmark of BIND vs Technitium DNS as complete resolvers. It is a **microbenchmark of cache eviction strategies**, inspired by DNS workloads. All cache implementations share a common interface and are benchmarked using **BenchmarkDotNet** under identical conditions. The full repository is public and reproducible on **[https://github.com/zbalkan/CacheBenchmark](https://github.com/zbalkan/CacheBenchmark)**

The cache strategies I used are:

- No eviction as baseline (see below)
- FIFO
- LFU
- LRU
- MRU
- [SIEVE](https://cachemon.github.io/SIEVE-website/)
- [SEER](https://www.usenix.org/conference/nsdi24/presentation/lei)
- [Incremental LRU](https://ieeexplore.ieee.org/abstract/document/10908863)
- Technitium DNS Cache

I need to specify that Technitium DNS uses a sophisticated, protocol-aware cache. To make benchmarking feasible, compromises were necessary. The benchmarked Technitium-style cache does not model DNS zones, TTL expiration, serve-stale behavior, DNSSEC metadata, EDNS Client Subnet partitioning, or hierarchical eviction. Eviction is simplified into a global, time-based heuristic rather than per-zone cleanup. What is preserved is the core design philosophy: minimal work on cache hits, eviction only under pressure, and avoidance of strict per-access ordering. The goal is behavioral comparability, not full DNS correctness.

The baseline value I used, `NoEvictionCache`, is **not a cache**. It is a `ConcurrentDictionary` with no eviction logic and exists only to quantify the overhead introduced by eviction policies.

## Results

```plaintext
BenchmarkDotNet v0.15.8, Windows 11 (10.0.26200.7462/25H2/2025Update/HudsonValley2)
11th Gen Intel Core i5-1135G7 2.40GHz (Max: 2.42GHz), 1 CPU, 8 logical and 4 physical cores
.NET SDK 9.0.308
  [Host]     : .NET 9.0.11 (9.0.11, 9.0.1125.51716), X64 RyuJIT x86-64-v4
  Job-NPXNLT : .NET 9.0.11 (9.0.11, 9.0.1125.51716), X64 RyuJIT x86-64-v4

IterationCount=10  LaunchCount=5  WarmupCount=5  

```

| Method                       | Mean                | Error          | StdDev           | Median               | Completed Work Items | Lock Contentions | Gen0     | Code Size | Allocated |
|----------------------------- |--------------------:|---------------:|-----------------:|---------------------:|---------------------:|-----------------:|---------:|----------:|----------:|
| FifoCache_ResolveAll         |           216.87 ns |      40.350 ns |        81.509 ns |            199.42 ns |                    - |                - |   0.0324 |   1,312 B |     136 B |
| IlruCache_ResolveAll         |           202.07 ns |      56.839 ns |       108.142 ns |            152.94 ns |                    - |                - |   0.0439 |   2,291 B |     184 B |
| LfuCache_ResolveAll          |           114.54 ns |       5.877 ns |        11.462 ns |            112.13 ns |                    - |                - |   0.0324 |   2,282 B |     136 B |
| LruCache_ResolveAll          |           119.30 ns |       5.012 ns |         9.536 ns |            116.39 ns |                    - |                - |   0.0324 |   1,824 B |     136 B |
| MruCache_ResolveAll          |           113.40 ns |       4.721 ns |         9.096 ns |            113.54 ns |                    - |                - |   0.0324 |   1,787 B |     136 B |
| NoEvictionCache_ResolveAll   |            98.83 ns |       6.401 ns |        12.332 ns |             93.04 ns |                    - |                - |   0.0421 |   2,569 B |     176 B |
| SeerCache_ResolveAll         |           219.73 ns |      66.427 ns |       132.662 ns |            142.92 ns |                    - |                - |   0.0324 |   2,366 B |     136 B |
| **SieveCache_ResolveAll**    |        **95.83 ns** |       5.957 ns |        11.896 ns |         **93.17 ns** |                    - |                - |   0.0324 |   1,868 B |     136 B |
| TdnsCache_ResolveAll         |           122.39 ns |       4.862 ns |         9.483 ns |            118.48 ns |                    - |                - |   0.0324 |   2,245 B |     136 B |
| FifoCache_RandomAccess       |     9,736,465.99 ns | 592,920.654 ns | 1,156,446.288 ns |      9,658,567.19 ns |              20.1875 |          80.9219 | 328.1250 |   2,191 B | 1365354 B |
| IlruCache_RandomAccess       |    14,076,530.59 ns | 707,254.912 ns | 1,428,689.912 ns |     14,063,241.41 ns |              13.3125 |         146.9688 | 437.5000 |   2,191 B | 1844066 B |
| LfuCache_RandomAccess        |    10,546,786.75 ns | 343,663.815 ns |   678,358.895 ns |     10,565,367.97 ns |              17.0938 |          89.5313 | 328.1250 |   2,191 B | 1364682 B |
| LruCache_RandomAccess        |    11,039,153.56 ns | 382,072.548 ns |   745,203.217 ns |     11,024,165.62 ns |              17.9219 |          85.9531 | 328.1250 |   2,191 B | 1364803 B |
| MruCache_RandomAccess        |    11,440,411.78 ns | 353,167.305 ns |   713,415.427 ns |     11,555,392.19 ns |              20.1875 |          90.4219 | 328.1250 |   2,191 B | 1365161 B |
| NoEvictionCache_RandomAccess |     9,036,427.95 ns | 603,672.681 ns | 1,191,591.069 ns |      8,559,477.73 ns |              16.2500 |          71.6406 | 421.8750 |   2,226 B | 1764518 B |
| SeerCache_RandomAccess       |    11,343,424.38 ns | 498,943.388 ns |   996,443.933 ns |     11,087,948.44 ns |              23.5000 |          88.1250 | 328.1250 |   2,191 B | 1365696 B |
| **SieveCache_RandomAccess**  | **9,261,351.21 ns** | 449,875.936 ns |   877,448.530 ns |  **9,230,184.38 ns** |              15.2500 |          70.8906 | 328.1250 |   2,191 B | 1364345 B |
| TdnsCache_RandomAccess       |    10,345,412.72 ns | 435,674.370 ns |   870,088.858 ns |     10,375,062.50 ns |              15.4063 |          63.0625 | 328.1250 |   2,191 B | 1364402 B |

This benchmark models a mostly warm cache where entries are already present. It represents the hot path of a DNS resolver.

## Key observations

### Benchmark 1: ResolveAll (Hot Cache Path)

- **SIEVE is effectively baseline-fast**, matching or slightly beating no eviction.
- LRU, LFU, and MRU cluster closely together.
- Technitium-style cache stays in the same performance band as classic policies.
- SEER and FIFO pay a clear cost for additional bookkeeping.

## Benchmark 2: RandomAccess (Eviction-Heavy Path)

- **SIEVE remains extremely close to the no-eviction baseline**, even under pressure.
- Technitium-style cache performs competitively and remains stable.
- Incremental LRU trades speed for predictability.
- SEER’s theoretical optimality does not translate into practical speed here.

## Conclusion

This experiment does not prove that one DNS server is “faster” than another. What it does show is that:

- **SIEVE is an excellent general-purpose eviction algorithm**, especially for highly concurrent systems.
- Classic LRU variants are still competitive but increasingly costly.
- Technitium DNS’s cache design makes sensible trade-offs that remain performant even when simplified.
- The cost of eviction logic itself is often more important than the eviction policy name.

If anything, the strongest lesson here is that **doing less work on the hot path beats cleverness**—a principle both BIND and Technitium DNS seem to have embraced in different ways.

The full benchmark code and data are available here: **[https://github.com/zbalkan/CacheBenchmark](https://github.com/zbalkan/CacheBenchmark)**

Further work could include TTL-aware eviction, zone-local buckets, and mixed read/write ratios to move even closer to real resolver behavior. And, I need to tell that **no, my friend, Technitium DNS is not faster than bind, at least in cache performance**.
